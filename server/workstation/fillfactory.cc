#include <QBitmap>

#include "fillfactory.h"
#include "vdi.h"
#include "workstation.h"

#define PATTERN(x,y)   (((x) * 10000) + y)


/*****************************************************************************\
|* Bitmap patterns
\*****************************************************************************/

static unsigned char _errorBits[] = {
	0x00, 0x00, 0x10, 0x08, 0x38, 0x1c, 0x7c, 0x3e, 0xfe, 0x7f, 0x7c, 0x3e,
	0x78, 0x1e, 0x70, 0x0e, 0xf0, 0x0f, 0x78, 0x1e, 0x7c, 0x3e, 0xfe, 0x7f,
	0x7c, 0x3e, 0x38, 0x1c, 0x10, 0x08, 0x00, 0x00};

static unsigned char _userBits[] = {
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,

	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
	0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,

	0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
	0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
	0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,
	0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,

	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
};


static unsigned char _pt2_Dots1[] = {
	0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00,
	0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
	0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00};

static unsigned char _pt2_Dots2[] = {
	0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00,
	0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00,
	0x55, 0x55, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00};

static unsigned char _pt2_Lines1[] = {
	0xaa, 0xaa, 0x11, 0x11, 0xaa, 0xaa, 0x44, 0x44, 0xaa, 0xaa, 0x11, 0x11,
	0xaa, 0xaa, 0x44, 0x44, 0xaa, 0xaa, 0x11, 0x11, 0xaa, 0xaa, 0x44, 0x44,
	0xaa, 0xaa, 0x11, 0x11, 0xaa, 0xaa, 0x44, 0x44};

static unsigned char _pt2_Dots_Dark[] = {
	0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
	0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55,
	0xaa, 0xaa, 0x55, 0x55, 0xaa, 0xaa, 0x55, 0x55};

static unsigned char _pt2_Dots_VDark[] = {
	0xaa, 0xaa, 0x77, 0x77, 0xaa, 0xaa, 0xdd, 0xdd, 0xaa, 0xaa, 0x77, 0x77,
	0xaa, 0xaa, 0xdd, 0xdd, 0xaa, 0xaa, 0x77, 0x77, 0xaa, 0xaa, 0xdd, 0xdd,
	0xaa, 0xaa, 0x77, 0x77, 0xaa, 0xaa, 0xdd, 0xdd};

static unsigned char _pt2_Lines1_Dark[] = {
	0xff, 0xff, 0x55, 0x55, 0xff, 0xff, 0x55, 0x55, 0xff, 0xff, 0x55, 0x55,
	0xff, 0xff, 0x55, 0x55, 0xff, 0xff, 0x55, 0x55, 0xff, 0xff, 0x55, 0x55,
	0xff, 0xff, 0x55, 0x55, 0xff, 0xff, 0x55, 0x55};

static unsigned char _pt2_Lines1_VDark[] = {
	0xee, 0xee, 0xff, 0xff, 0xbb, 0xbb, 0xff, 0xff, 0xee, 0xee, 0xff, 0xff,
	0xbb, 0xbb, 0xff, 0xff, 0xee, 0xee, 0xff, 0xff, 0xbb, 0xbb, 0xff, 0xff,
	0xee, 0xee, 0xff, 0xff, 0xbb, 0xbb, 0xff, 0xff};

static unsigned char _pt2_Solid[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

static unsigned char _pt2_Bricks[] = {
	0xff, 0xff, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
	0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,
	0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0xff, 0xff};

static unsigned char _pt2_Bricks_Diag[] = {
	0x05, 0x05, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08,
	0x04, 0x04, 0x02, 0x02, 0x05, 0x05, 0x88, 0x88, 0x50, 0x50, 0x20, 0x20,
	0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02};

static unsigned char _pt2_Circumflex[] = {
	0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0xa0, 0xa0, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x04, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40,
	0xa0, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04};

static unsigned char _pt2_Shells[] = {
	0x41, 0x41, 0x80, 0x80, 0x80, 0x80, 0xaa, 0xaa, 0x14, 0x14, 0x08, 0x08,
	0x08, 0x08, 0xaa, 0xaa, 0x41, 0x41, 0x80, 0x80, 0x80, 0x80, 0xaa, 0xaa,
	0x14, 0x14, 0x08, 0x08, 0x08, 0x08, 0xaa, 0xaa};

static unsigned char _pt2_Diag_Dash[] = {
	0x40, 0x40, 0x80, 0x80, 0x01, 0x01, 0x00, 0x00, 0x10, 0x10, 0x08, 0x08,
	0x04, 0x04, 0x00, 0x00, 0x40, 0x40, 0x80, 0x80, 0x01, 0x01, 0x00, 0x00,
	0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00};

static unsigned char _pt2_Ugly[] = {
	0x40, 0x40, 0x80, 0x80, 0x01, 0x01, 0x00, 0x00, 0x10, 0x10, 0x08, 0x08,
	0x04, 0x04, 0x00, 0x00, 0x40, 0x40, 0x80, 0x80, 0x01, 0x01, 0x00, 0x00,
	0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00};

static unsigned char _pt2_Dots_Sparse[] = {
	0x40, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static unsigned char _pt2_Weave[] = {
	0xc7, 0xc7, 0xef, 0x6e, 0x7e, 0x3c, 0x3f, 0x1e, 0x1f, 0x8f, 0xbb, 0xdb,
	0xf1, 0xf1, 0xe3, 0xe3, 0xc7, 0xc7, 0xef, 0x6e, 0x7e, 0x3c, 0x3f, 0x1e,
	0x1f, 0x8f, 0xbb, 0xdb, 0xf1, 0xf1, 0xe3, 0xe3};

static unsigned char _pt2_Line_Dot[] = {
	0x22, 0x22, 0x05, 0x05, 0x88, 0x88, 0x50, 0x50, 0x22, 0x22, 0x00, 0x00,
	0xaa, 0xaa, 0x00, 0x00, 0x22, 0x22, 0x05, 0x05, 0x88, 0x88, 0x50, 0x50,
	0x22, 0x22, 0x00, 0x00, 0xaa, 0xaa, 0x00, 0x00};

static unsigned char _pt2_Square_Dot[] = {
	0x55, 0x55, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
	0x40, 0x40, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00,
	0x44, 0x44, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00};

static unsigned char _pt2_Balls[] = {
	0x1f, 0x1f, 0x1f, 0x1f, 0xee, 0xee, 0x91, 0x91, 0xf1, 0xf1, 0xf1, 0xf1,
	0xee, 0xee, 0x19, 0x19, 0x1f, 0x1f, 0x1f, 0x1f, 0xee, 0xee, 0x91, 0x91,
	0xf1, 0xf1, 0xf1, 0xf1, 0xee, 0xee, 0x19, 0x19};

static unsigned char _pt2_Roof1[] = {
	0x02, 0x02, 0x05, 0x05, 0xf8, 0xf8, 0x20, 0x20, 0x20, 0x20, 0x50, 0x50,
	0x8f, 0x8f, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0xf8, 0xf8, 0x20, 0x20,
	0x20, 0x20, 0x50, 0x50, 0x8f, 0x8f, 0x02, 0x02};

static unsigned char _pt2_Roof2[] = {
	0x21, 0x21, 0x12, 0x12, 0x0c, 0x0c, 0x30, 0x30, 0x40, 0x40, 0x80, 0x80,
	0x80, 0x80, 0xc0, 0xc0, 0x21, 0x21, 0x12, 0x12, 0x0c, 0x0c, 0x30, 0x30,
	0x40, 0x40, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0};

static unsigned char _pt2_Checker[] = {
	0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0x1e, 0x1e, 0x1e, 0x1e,
	0x1e, 0x1e, 0x1e, 0x1e, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1,
	0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e};

static unsigned char _pt2_Diamond[] = {
	0xc1, 0xc1, 0xe3, 0xe3, 0xf7, 0xf7, 0xff, 0xff, 0xf7, 0xf7, 0xe3, 0xe3,
	0xc1, 0xc1, 0x80, 0x80, 0xc1, 0xc1, 0xe3, 0xe3, 0xf7, 0xf7, 0xff, 0xff,
	0xf7, 0xf7, 0xe3, 0xe3, 0xc1, 0xc1, 0x80, 0x80};

static unsigned char _pt2_Chevron[] = {
	0x88, 0x88, 0x44, 0x44, 0xff, 0xff, 0x22, 0x22, 0x44, 0x44, 0x88, 0x88,
	0xff, 0xff, 0x11, 0x11, 0x88, 0x88, 0x44, 0x44, 0xff, 0xff, 0x22, 0x22,
	0x44, 0x44, 0x88, 0x88, 0xff, 0xff, 0x44, 0x44};

static unsigned char _pt3_Diag1[] = {
	0x01, 0x01, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08,
	0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20,
	0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02};

static unsigned char _pt3_Diag2[] = {
	0x03, 0x03, 0x81, 0x81, 0xc0, 0xc0, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18,
	0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03, 0x81, 0x81, 0xc0, 0xc0, 0x60, 0x60,
	0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06};

static unsigned char _pt3_Cross_Hatch[] = {
	0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24,
	0x42, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18,
	0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x81, 0x81};

static unsigned char _pt3_Vertical[] = {
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02};

static unsigned char _pt3_Horizontal[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00};

static unsigned char _pt3_Square[] = {
	0x02, 0x02, 0xff, 0xff, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xff, 0xff, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02};

static unsigned char _pt3_Diag3[] = {
	0x01, 0x01, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08,
	0x04, 0x04, 0x02, 0x02, 0x01, 0x01, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20,
	0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02};

static unsigned char _pt3_Diag3_Bold[] = {
	0x03, 0x03, 0x81, 0x81, 0xc0, 0xc0, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18,
	0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03, 0x81, 0x81, 0xc0, 0xc0, 0x60, 0x60,
	0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06};

static unsigned char _pt3_Cross_Hatch2[] = {
	0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24,
	0x42, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18,
	0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x81, 0x81};

static unsigned char _pt3_Vertical2[] = {
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};

static unsigned char _pt3_Horizontal2[] = {
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static unsigned char _pt3_Square2[] = {
	0xff, 0xff, 0x11, 0x11, 0x55, 0x55, 0x11, 0x11, 0xff, 0xff, 0x11, 0x11,
	0x55, 0x55, 0x11, 0x11, 0xff, 0xff, 0x11, 0x11, 0x55, 0x55, 0x11, 0x11,
	0xff, 0xff, 0x11, 0x11, 0x55, 0x55, 0x11, 0x11};


/*****************************************************************************\
|* Colour index conversion
\*****************************************************************************/
#if 0
static const short _devtovdi8[256] =
	{
	0, 2, 3, 6, 4, 7, 5, 8, 9, 10, 11,14,12,15,13,255,
	16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
	32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,
	48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
	64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,
	80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
	96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
	176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
	192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
	208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
	224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,1
	};
#endif

/*****************************************************************************\
|* Class definition
\*****************************************************************************/
FillFactory::FillFactory(QObject *parent)
	: QObject{parent}
	{
	// Create an error pixmap and store it as {6,0}
	_create(FIS_ERROR, 0, _errorBits);

	// The memory needs to be delete-able for 4-bit images
	_create(FIS_USER, 0, _userBits, 4);
	}


/*****************************************************************************\
|* Return a pixmap for a given pattern and type
\*****************************************************************************/
QImage& FillFactory::patternFor(int type, int style)
	{
	/*************************************************************************\
	|* Check to see if we've already done it
	\*************************************************************************/
	int patternId = PATTERN(type, style);
	if (_patterns.contains(patternId))
		return _patterns[patternId];

	/*************************************************************************\
	|* See if it's a recognised variant
	\*************************************************************************/
	uint8_t *pattern = nullptr;

	switch (type)
		{
		case FIS_PATTERN:
			switch (style)
				{
				case PT_DOTS1:
					pattern = _pt2_Dots1;
					break;
				case PT_DOTS2:
					pattern = _pt2_Dots2;
					break;
				case PT_LINES1:
					pattern = _pt2_Lines1;
					break;
				case PT_DOTS_DARK:
					pattern = _pt2_Dots_Dark;
					break;
				case PT_DOTS_VDARK:
					pattern = _pt2_Dots_VDark;
					break;
				case PT_LINES1_DARK:
					pattern = _pt2_Lines1_Dark;
					break;
				case PT_LINES1_VDARK:
					pattern = _pt2_Lines1_VDark;
					break;
				case PT_SOLID:
					pattern = _pt2_Solid;
					break;
				case PT_BRICKS:
					pattern = _pt2_Bricks;
					break;
				case PT_BRICKS_DIAG:
					pattern = _pt2_Bricks_Diag;
					break;
				case PT_CIRCUMFLEX:
					pattern = _pt2_Circumflex;
					break;
				case PT_SHELLS:
					pattern = _pt2_Shells;
					break;
				case PT_DIAG_DASH:
					pattern = _pt2_Diag_Dash;
					break;
				case PT_UGLY:
					pattern = _pt2_Ugly;
					break;
				case PT_DOTS_SPARSE:
					pattern = _pt2_Dots_Sparse;
					break;
				case PT_WEAVE:
					pattern = _pt2_Weave;
					break;
				case PT_LINE_DOT:
					pattern = _pt2_Line_Dot;
					break;
				case PT_SQUARE_DOT:
					pattern = _pt2_Square_Dot;
					break;
				case PT_BALLS:
					pattern = _pt2_Balls;
					break;
				case PT_ROOF1:
					pattern = _pt2_Roof1;
					break;
				case PT_ROOF2:
					pattern = _pt2_Roof2;
					break;
				case PT_CHECKER:
					pattern = _pt2_Checker;
					break;
				case PT_DIAMONDS:
					pattern = _pt2_Diamond;
					break;
				case PT_CHEVRON:
					pattern = _pt2_Chevron;
					break;
				default:
					return _patterns[PATTERN(FIS_ERROR,0)];
				}
			break;

		case FIS_USER:
			return _patterns[PATTERN(FIS_USER,0)];

		case FIS_HATCH:
			switch (style)
				{
				case PT_DIAG1:
					pattern = _pt3_Diag1;
					break;
				case PT_DIAG2:
					pattern = _pt3_Diag2;
					break;
				case PT_CROSS_HATCH:
					pattern = _pt3_Cross_Hatch;
					break;
				case PT_VERTICAL:
					pattern = _pt3_Vertical;
					break;
				case PT_HORIZONTAL:
					pattern = _pt3_Horizontal;
					break;
				case PT_SQUARE:
					pattern = _pt3_Square;
					break;
				case PT_DIAG3:
					pattern = _pt3_Diag3;
					break;
				case PT_DIAG3_BOLD:
					pattern = _pt3_Diag3_Bold;
					break;
				case PT_CROSS_HATCH2:
					pattern = _pt3_Cross_Hatch2;
					break;
				case PT_VERTICAL2:
					pattern = _pt3_Vertical2;
					break;
				case PT_HORIZONTAL2:
					pattern = _pt3_Horizontal2;
					break;
				case PT_SQUARE2:
					pattern = _pt3_Square2;
					break;
				default:
					return _patterns[PATTERN(FIS_ERROR,0)];
				}
			break;

		default:
			return _patterns[PATTERN(FIS_ERROR,0)];
		}

	return _create(type, style, pattern);
	}

/*****************************************************************************\
|* Create an image from an MFDB
\*****************************************************************************/
QImage * FillFactory::imageFromMFDB(MFDB *mfdb, Workstation *ws)
	{
	QImage *img = nullptr;

	if (IS_OK(mfdb))
		{
		switch (mfdb->fd_nplanes)
			{
			default:
				img = _imageFromMFDB1(mfdb, ws);
				break;
			case 4:
				img = _imageFromMFDB4(mfdb, ws);
				break;
			case 8:
				img = _imageFromMFDB8(mfdb, ws);
				break;
			case 16:
				WARN("16-bit images currently not implemented");
				// FIXME: fmt = QImage::Format_RGB16;
				break;
			case 24:
				WARN("24-bit images currently not implemented");
				// FIXME: fmt = QImage::Format_RGB888;
				break;
			case 32:
				WARN("Unknown image depth of %d", mfdb->fd_nplanes);
				break;
			}
		}

	return img;
	}


/*****************************************************************************\
|* Set the user-fill
\*****************************************************************************/
bool FillFactory::setUserFill(MFDB *mfdb, Workstation *ws)
	{
	bool ok		= false;
	QImage *img = imageFromMFDB(mfdb, ws);
	if ((img != nullptr) && (img->format() != 0))
		{
		_patterns[PATTERN(FIS_USER,0)] = *img;
		ok = true;
		}

	if (img != nullptr)
		delete img;
	return ok;
	}


#pragma mark - Private Methods

/*****************************************************************************\
|* Return an image for a given pattern and type.
|*
|* Note the use of mfdb->fd_r1 here. We set it to 0 to indicate we do not have
|* to free the fd_addr field (that's the caller's job). If it is set to 1 by
|* intermediate code, then we do in fact have to free the memory
\*****************************************************************************/
QImage& FillFactory::_create(int type, int style, uint8_t *src, int planes)
	{
	int patternId = PATTERN(type, style);

	if (planes == 1)
		{
		QImage img(src, 16, 16, 2, QImage::Format_Mono);
		img.setColorCount(2);
		_patterns[patternId] = img;
		}
	else
		{
		MFDB mfdb;
		mfdb.fd_addr		= src;
		mfdb.fd_h			= 16;
		mfdb.fd_w			= 16;
		mfdb.fd_nplanes		= planes;
		mfdb.fd_wdwidth		= 4;
		mfdb.fd_stand		= MFDB_STANDARD;
		mfdb.fd_r1			= 0;					// Do not delete memory

		Workstation *ws		= VDI::sharedInstance().top();
		QImage *img			= imageFromMFDB(&mfdb, ws);
		_patterns[patternId] = *img;

		delete img;
		if (mfdb.fd_r1)
			DELETE_TYPED_ARRAY(mfdb.fd_addr, uint8_t);
		}
	return _patterns[patternId];
	}

/*****************************************************************************\
|* Create a pixmap from a 1-bit MFDB
\*****************************************************************************/
QPixmap FillFactory::bitmapFromMFDB(MFDB *mfdb, Palette pal)
	{
	uint16_t *ptr	= (uint16_t *)(mfdb->fd_addr);
	int numWords	= mfdb->fd_wdwidth * mfdb->fd_h;
	for (int i=0; i<numWords; i++)
		{
		*ptr = ntohs(*ptr);
		ptr ++;
		}

	QImage img((uchar *)mfdb->fd_addr,
			   mfdb->fd_w,
			   mfdb->fd_h,
			   mfdb->fd_wdwidth*2,
			   QImage::Format_Mono);

	img.setColorTable(pal);

	QPixmap bmp = QPixmap::fromImage(img);
	return bmp;
	}

/*****************************************************************************\
|* Create an image from a 1-bit MFDB
\*****************************************************************************/
QImage * FillFactory::_imageFromMFDB1(MFDB *mfdb, Workstation *ws)
	{
	QList<QRgb> palette;

	uint16_t *ptr	= (uint16_t *)(mfdb->fd_addr);
	int numWords	= mfdb->fd_wdwidth * mfdb->fd_h;
	for (int i=0; i<numWords; i++)
		{
		*ptr = ntohs(*ptr);
		ptr ++;
		}

	QImage *img = new QImage((uchar *)mfdb->fd_addr,
							 mfdb->fd_w,
							 mfdb->fd_h,
							 mfdb->fd_wdwidth*2,
							 QImage::Format_Mono);
	if (ws->colourTable(palette))
		img->setColorTable(palette);

	return img;
	}

/*****************************************************************************\
|* Create an image from a 4-bit MFDB. We need to convert this to an 8-bit img
\*****************************************************************************/
QImage * FillFactory::_imageFromMFDB4(MFDB *mfdb, Workstation *ws)
	{
	QImage *img			= nullptr;
	int skip			= (mfdb->fd_w & 1) ? 1 : 0;
	int wds				= (mfdb->fd_w + skip)/2;
	uint8_t *imgData	= new uint8_t[wds * 2 * mfdb->fd_h];

	if (imgData)
		{
		int idx = 0;
		for (int i=0; i<mfdb->fd_h; i++)
			{
			uint8_t *data = ((uint8_t *)mfdb->fd_addr)
			+ i * mfdb->fd_wdwidth * 2;
			for (int j=0; j<mfdb->fd_w; )
				{
				uint8_t pixels	= *data ++;
				imgData[idx++]	= pixels >> 4;
				j++;
				if (j < mfdb->fd_w)
					{
					imgData[idx++]	= pixels & 0xf;
					j++;
					}
				}
			idx += skip;
			}

		/*********************************************************************\
		|* Remap the image with the 8-bit data
		\*********************************************************************/
		if (mfdb->fd_r1)
			delete [] ((uint8_t *)(mfdb->fd_addr));
		mfdb->fd_addr		= imgData;
		mfdb->fd_nplanes	= 8;
		mfdb->fd_wdwidth	= wds;
		mfdb->fd_r1			= 1;

		img = new QImage(mfdb->fd_w,
						 mfdb->fd_h,
						 QImage::Format_Indexed8);
		uint8_t *bits	= img->bits();
		uint8_t *src	= (uint8_t *) mfdb->fd_addr;

		for (int i=0; i<mfdb->fd_h; i++)
			{
			memcpy(bits, src, mfdb->fd_w);
			src  += mfdb->fd_w;
			bits += img->bytesPerLine();
			}

		QList<QRgb> palette;
		if (ws->colourTable(palette))
			img->setColorTable(palette);
		}
	else
		WARN("Cannot allocate 8-bit image for 4-bit data in vro_cpyfm");

	return img;
	}

/*****************************************************************************\
|* Create an image from an 8-bit MFDB
\*****************************************************************************/
QImage * FillFactory::_imageFromMFDB8(MFDB *mfdb, Workstation *ws)
	{
	QList<QRgb> palette;
	QImage *img = new QImage((uchar *)mfdb->fd_addr,
							 mfdb->fd_w,
							 mfdb->fd_h,
							 mfdb->fd_wdwidth*2,
							 QImage::Format_Indexed8);
	if (ws->colourTable(palette))
		img->setColorTable(palette);

	QImage mask = img->createHeuristicMask();
	mask.invertPixels();
	img->setAlphaChannel(mask);

	return img;
	}


